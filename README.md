# 4. Операторы в Python

![img.png](img%2Fimg.png)

---

## Вступление

Добро пожаловать в тему операторов!

В программировании, независимо от языка, существуют операторы, характерные для большинства популярных языков.
Они позволяют выполнять различные действия и манипуляции с данными. Мы уверены, что полученные знания в этой теме,
также пригодятся вам, если вы решите изучать другие языки программирования.

В этой теме мы рассмотрим операторов Python, их функциональность, особенности и правила использования.

Информации в этой теме будет больше, чем в большинстве других разделов самоучителя. Однако не переживайте, если
сразу не запомните всё. В следующих темах вы будете регулярно возвращаться к этим знаниям и постепенно освоите их.
Пока держите эту тему под рукой как шпаргалку по операторам Python.

> **Обратите внимание**: мы затронем особый _моржовый_ оператор, который сочетает присваивание и сравнение
> в одной конструкции. Подробнее о его возможностях и применении вы узнаете в теме условных конструкций.
> ([Условные операторы](https://github.com/shox-py/topic_6/), [Циклы](https://github.com/shox-py/topic_7/))

---

## Содержание

- [Булевые значения](#булевые-значения)
- [Операторы сравнения](#операторы-сравнения)
- [Операторы присваивания](#операторы-присваивания)
- [Побитовые операторы](#побитовые-операторы)
- [Логические операторы](#логические-операторы)
- [Операторы `in` и `not in`](#операторы-in-и-not-in)
- [Операторы `is` и `is not`](#операторы-is-и-is-not)
- [`None` - специальное значение отсутствия значения](#None---специальное-значение-отсутствия-значения)
- [Приоритет операторов](#приоритет-операторов)
- [Моржовый оператор](#моржовый-оператор)
- [Задания](#задания)

---

## Булевые значения

В вашу коллекцию знаний о типах данных Python добавляется ещё один тип - `bool`. Он представлен всего двумя значениями:
`True` и `False`. В третьей теме мы частично касались этого типа, а теперь пришло время изучить его подробнее.

Булевые значения - основа логической алгебры, которая позволяет работать с высказываниями, их комбинациями
и определением истинности выражений.

**Пример из жизни**:

Представьте, что вы включаете свет в комнате. Выключатель имеет только два состояния:

- Включен - свет горит.
- Выключен - свет не горит.

В данном случае значение `True` соответствует включенному свету, а `False` - выключенному.
Третьего состояния для выключателя просто не существует.

Булевые значения играют важную роль в условных конструкциях `if`, `while` и операциях сравнения.
Они позволяют задавать условия, на основе которых принимаются решения: _выполняются_ действия или _пропускаются_.

**Пример**:

```python
is_valid = True
is_greater = False

print(is_valid)  # True
print(is_greater)  # False
```

Литералы `True` и `False` записываются без кавычек, поскольку они являются ключевыми словами языка Python.

> Префикс `is_` в названиях переменных часто используется для обозначения булевых значений.
> Это помогает сразу понять, что переменная отвечает на вопрос: `"Является ли?"`.
>
> **Пример**:
>
> - `is_valid` - "Является ли допустимым?"
> - `is_greater` - "Является ли большим?" или "Больше ли?"
> - `is_empty` - "Является ли пустым?"
>
> Использование такого подхода делает код удобным для чтения.
>
> ![prefix_is.png](img/prefix_is.png)

### Преобразование других типов в булевый тип

Python позволяет приводить различные типы данных к булевому типу с помощью встроенной функции `bool()`.
При этом некоторые значения будут интерпретироваться как `False`, а другие как `True`.

**Пример**:

```python
print(bool(0))  # False
print(bool(0.0))  # False
print(bool(''))  # False
print(bool(None))  # False
print(bool(False))  # False
```

Почему `False`?:

- `0`, `0.0`, `''` и значение `None` считаются ложными значениями в Python. Они представляют отсутствие
  (пустоту или нулевую величину). Это нужно запомнить, так как такие значения могут повлиять на выполнение условий.

**Пример**:

```python
print(bool(-17))  # True
print(bool(39))  # True
print(bool(1.6894))  # True
print(bool("Не пустая строка"))  # True
print(bool(True))  # True
```

Почему `True`?:

- Все остальные значения, кроме перечисленных в предыдущем примере, считаются истинными значениями.
  Например, числа (включая отрицательные), непустые строки и объекты всегда интерпретируются как `True`.

> **Важно**: Следующие значения функция `bool()` будет интерпретировать как `False`:
>
> - Число `0`
> - Число `0.0`
> - Пустые строки `''` или `""`
> - Значение `None`
> - Значение `False`
>
> Пустые коллекции: (_о коллекциях узнаете в следующей теме_.):
>
>   - `[]` - пустой список
>   - `{}` - пустой словарь
>   - `set()` - пустое множество
>   - `()` - пустой кортеж
>
> Все остальные значения, функцией `bool()` интерпретируются как `True`.

---

## Операторы сравнения

Операторы сравнения позволяют сравнивать значения различных типов данных, результатом такого сравнения
будет булевое значение.

### Таблица 4.1: Операторы сравнения

| Оператор |     Название     | Описание                                                           |
|:--------:|:----------------:|:-------------------------------------------------------------------|
|   `==`   |      равно       | проверяет, являются ли два значения равными.                       |
|   `!=`   |     не равно     | проверяет, являются ли два значения неравными.                     |
|   `>`    |      больше      | проверяет, является ли первое значение большим, чем второе.        |
|   `<`    |      меньше      | проверяет, является ли первое значение меньшим, чем второе.        |
|   `>=`   | больше или равно | проверяет, является ли первое значение большим или равным второму. |
|   `<=`   | меньше или равно | проверяет, является ли первое значение меньшим или равным второму. |

### Сравнение чисел

В программировании сравнение числа с числом происходит как в математике.

**Пример**:

```python
first_num: int = 10
second_num: float = 15.0

less_than: bool = first_num < second_num
less_than_or_equal: bool = first_num <= second_num

print(less_than)  # True
print(less_than_or_equal)  # True

greater_than: bool = first_num > second_num
greater_than_or_equal: bool = first_num >= second_num

print(greater_than)  # False
print(greater_than_or_equal)  # False

equal_to: bool = first_num == second_num
not_equal_to: bool = first_num != second_num

print(equal_to)  # False
print(not_equal_to)  # True
```

В примере выше с помощью разных операторов сравнения мы сравнили числа типа `int` и `float`,
вы можете эти операции выполнить в любой комбинации целое число с целым числом, дробное число с дробным и т.д.
поведение операторов сравнения между числами будет всегда одинаково.

### Сравнение строк

В жизни вы наверняка сталкивались с ситуацией, когда сравнивали два текста или видели, как это делал кто-то другой.
Часто длинное слово воспринимается как **большее**.

В программировании длина строк действительно играет роль, но это лишь один из факторов. Мы не можем сразу утверждать,
что строки равны, только на основании их длины. Даже если длина одинаковая, строки могут отличаться.

**Основные правила сравнения строк**:

1. Если строки разной длины:

    - если первые символы совпадают, то более короткая строка считается `меньше` длинной строки.
    - если первые символы разные, то результат сравнения определяется сравнением этих символов.

2. Если длины строк равны:

    - то сравнение происходит символ за символом, начиная с первого:

        - Как только встречается первый различающийся символ, результат сравнения определяется этим символом.
        - Если не найдено ни одного различающегося символа, тогда строки считаются равными.

> Сравнение строк выполняется на основе их кодовых точек (числовых значений символов) в таблице
> [Unicode](https://home.unicode.org/) или [ASCII](https://snipp.ru/handbk/table-ascii).

1. Если строки разной длины.

**Пример**:

```python
first_line: str = "кот"
second_line: str = "котик"

print(first_line < second_line)  # True
```

Более короткая строка меньше длинной, так как все их первые символы совпадают.

**Пример**:

```python
first_line: str = "ананас"
second_line: str = "арбуз"

print(first_line > second_line)  # False
```

Сравнение начинается с первых символов `'а'` и `'а'`, которые равны. Проверка переходит ко вторым символам
`'н'` и `'р'`. Символ `'н'` меньше символа `'р'` в таблице Unicode, поэтому результат сравнения `False`.

2. Если длины строк равны.

**Пример**:

```python
first_line: str = "собака"
second_line: str = "сова"

print(first_line < second_line)  # True
```

Сравнение происходит символ за символом. Результат определяется первым различающимся символом: `'б'` меньше `'в'`.

**Пример**:

```python
first_line: str = "груша"
second_line: str = "груша"

print(first_line == second_line)  # True
```

Все символы совпадают, значит строки равны.

3. Регистр имеет значение.

**Пример**:

```python
first_line: str = "Яблоко"
second_line: str = "яблоко"

print(first_line < second_line)  # True
```

Заглавная буква `'Я'` меньше строчной `'я'` в таблице Unicode.

4. Оператор `!=`.

Логика работы оператора _не равно_ уже следует из основного правила сравнения строк, возвращает:

- `True`, если строки различны по длине или хотя бы один символ отличается.

**Пример**:

```python
first_line: str = "яблоко"
second_line: str = "груша"

print(first_line != second_line)  # True
```

- `False`, если строки полностью совпадают.

**Пример**:

```python
first_line: str = "арбуз"
second_line: str = "арбуз"

print(first_line != second_line)  # False
```

Запомните, регистр букв играет ключевую роль при сравнении строк. Например, строки `"Мандарины"` и `"мАндаринЫ"`
не равны, так как заглавные и строчные буквы имеют разные кодовые точки.

### Сравнение чисел и строк

В Python сравнивать значения разных типов данных обычно невозможно. Например, сравнение чисел и строк приведет
к ошибке `TypeError`. Это связано с тем, что операторы сравнения `<`, `<=`, `>`, `>=` не поддерживают совместимость
между строками и числами.

**Пример**:

```python
year: int = 2099
month: str = "февраль"

print(year < month)  # TypeError: '<' not supported between instances of 'int' and 'str'
print(year <= month)  # TypeError: '<=' not supported between instances of 'int' and 'str'
print(year > month)  # TypeError: '>' not supported between instances of 'int' and 'str'
print(year >= month)  # TypeError: '>=' not supported between instances of 'int' and 'str'
```

Однако операторы `==` и `!=` работают даже для сравнения чисел и строк. Это происходит потому, что они в первую
очередь проверяют тип данных.

**Пример**:

```python
year: int = 2088
month: str = "август"

print(year == month)  # False
print(year != month)  # True
```

Если типы сравниваемых значений отличаются, результат сравнения будет однозначным:

- `==` - возвращает `False`, так как числа и строки имеют разные типы.
- `!=` - возвращает `True`, поскольку типы значений различны.

> Остальные нюансы строк рассматривается в теме "**Работа со строками**".

---

## Операторы присваивания

Вы уже знакомы с оператором присваивания `=`, который позволяет присваивать значения переменным. 
Мы обсуждали это в предыдущей теме. Теперь пришло время рассмотреть полный список операторов присваивания,

### Таблица 4.2: Операторы присваивания

| Оператор |               Название                | Описание                                                                   |
|:--------:|:-------------------------------------:|:---------------------------------------------------------------------------|
|   `=`    |             присваивание              | присваивает переменной значение, указанное справа.                         |
|   `+=`   |       присваивание со сложением       | увеличивает значение переменной на указанное значение.                     |
|   `-=`   |       присваивание с вычитанием       | уменьшает значение переменной на указанное значение.                       |
|   `*=`   |       присваивание с умножением       | умножает значение переменной на указанное значение.                        |
|   `/=`   |       	присваивание с делением        | делит значение переменной на указанное значение.                           |
|   `%=`   |    присваивание с остатком деления    | присваивает переменной остаток от деления на указанное значение.           |
|  `//=`   | присваивание с целочисленным делением | делит значение переменной на указанное значение, отбрасывая дробную часть. |
|  `**=`   | присваивание с возведением в степень  | возводит значение переменной в указанную степень.                          |

### Присваивание с добавлением

Нет смысла подробно рассматривать каждый оператор присваивания, поскольку их использование схоже. 
Рассмотрим пример с оператором `+=`, чтобы понять, как работают сокращенные формы записи.

**Пример**:

```python
number_of_apples_in_box: int = 10

number_of_apples_in_box = number_of_apples_in_box + 5

print(number_of_apples_in_box)  # 15
```

В этом примере переменная `number_of_apples_in_box` изначально содержит 10. Затем мы добавляем 5 яблок 
и обновляем переменную до 15.

Того же результата можно добиться, переписав этот код более компактно, используя оператор `+=`.

**Пример**:

```python
number_of_apples_in_box: int = 10

number_of_apples_in_box += 5

print(number_of_apples_in_box)  # 15
```

Оба варианта записи работают одинаково, но сокращенная форма делает код более компактным и удобным для чтения.

- Присваивание с вычитанием

**Пример**:

```python
distance_to_destination: int = 150

distance_to_destination -= 30

print(distance_to_destination)  # 120
```

- Присваивание с умножением

**Пример**:

```python
salary: int = 50000

salary *= 2

print(salary)
```

- Присваивание с делением

**Пример**:

```python
total_cost: float = 100.0

total_cost /= 4

print(total_cost)  # 25.0
```

- Присваивание с остатком деления 

**Пример**:

```python
candies: int = 27

candies %= 4

print(candies)  # 3
```

- Присваивание с целочисленным делением

**Пример**:

```python
candies: int = 30

candies //= 8

print(candies)  # 3
```

- Присваивание с возведением в степень

**Пример**:

```python
side: int = 3

side **= 2

print(side)  # 9
```

Сокращенные операторы присваивания делают код более лаконичным и читабельным. Однако в некоторых случаях 
предпочтительнее использовать полную версию, чтобы явно отобразить все этапы вычислений.

Выбор стиля написания остается за вами, но мы рекомендуем использовать компактную запись, 
если это не снижает читабельность кода.

---

## Побитовые операторы

Побитовые операторы работают с данными на уровне их двоичного представления. 
Они применяются для выполнения операций с отдельными битами, в задачах низкоуровневого программирования.


> Если эта тема кажется сложной, вы можете пропустить её и вернуться позже, когда почувствуете 
> себя более уверенно в программировании. Не забывайте, что процесс обучения - это непрерывный и постоянный процесс, и важно гибко подстраиваться под свои 
    потребности и интересы.

Что вы должны знать, чтобы понять этот раздел:

- [Wikipedia: Что такое битовые операции?](https://ru.wikipedia.org/wiki/%D0%91%D0%B8%D1%82%D0%BE%D0%B2%D0%B0%D1%8F_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F)
- [Bolshoyvopros: Как перевести числа в двоичную систему?](https://www.bolshoyvopros.ru/questions/1187-kak-perevesti-chisla-v-dvoichnuju-sistemu.html)
- [Video: Что такое таблица истинности?](https://vkvideo.ru/video-188087805_456239021)
- [Wikipedia: Что такое унарный и бинарный операторы?](https://ru.wikipedia.org/wiki/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D1%8F_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))

### Таблица 4.3: Побитовые операторы

|      Оператор       |               Название               | Описание                                                                              |
|:-------------------:|:------------------------------------:|:--------------------------------------------------------------------------------------|
|         `&`         |        побитовое **И** (AND)         | возвращает результат побитового **И** для каждой пары битов операндов.                |
| <code>&#124;</code> |        побитовое **ИЛИ** (OR)        | возвращает результат побитового **ИЛИ** для каждой пары битов операндов.              |
|         `^`         | побитовое  **Исключающее ИЛИ** (XOR) | возвращает результат побитового **исключающего ИЛИ** для каждой пары битов операндов. |
|         `~`         |   побитовое отрицание (_НЕ_ или NOT)   | возвращает результат побитового отрицания операнда.                                   |
|        `<<`         |          сдвиг битов влево           | сдвигает биты операнда влево на указанное количество позиций.                         |
|        `>>`         |          сдвиг битов вправо          | сдвигает биты операнда вправо на указанное количество позиций.                        |

### Побитовое И

> Бинарный оператор

![bitwise_and.png](img/bitwise_and.png)

<small>Источник изображения: [Pythonchik](https://pythonchik.ru/)</small>

**Пример**:

```python
a: int = 11
b: int = 34

c: int = a & b
print(c)  # 2
```

Побитовое **И** (AND) - сравнивает биты и в результате даёт `1` только в том случае, 
если оба сравниваемых бита равны `1`. В остальных случаях результат будет `0`.

### Побитовое ИЛИ

> Бинарный оператор

![bitwise_and.png](img/bitwise_or.png)

<small>Источник изображения: [Pythonchik](https://pythonchik.ru/)</small>

**Пример**:

```python
a: int = 11
b: int = 34

c: int = a | b
print(c)  # 43
```

Побитовое **ИЛИ** (OR) - двоичный разряд результата равен `0` только тогда, когда оба соответствующих 
бита равны `0`. Во всех других случаях двоичный результат равен `1`.

### Побитовое Исключающее ИЛИ

> Бинарный оператор

![bitwise_and.png](img/bitwise_xor.png)

<small>Источник изображения: [Pythonchik](https://pythonchik.ru/)</small>

**Пример**:

```python
a: int = 11
b: int = 34

c: int = a ^ b
print(c)  # 41
```

Побитовое  **Исключающее ИЛИ** (XOR) - ставит `1` на бит результата, для которого только один из соответствующих 
битов операндов равен `1`, но не оба. 

### Побитовое отрицание (НЕ или NOT)

> Унарный оператор

![bitwise_and.png](img/bitwise_not.png)

<small>Источник изображения: [Pythonchik](https://pythonchik.ru/)</small>

**Пример**:

```python
a: int = 11

c: int = ~a
print(c)  # -12
```

Побитовое отрицание (НЕ или NOT) - инвертирует все биты операнда. То, что было `1`, становится `0`, и наоборот.

### Сдвиг битов влево

> Бинарный оператор

![bitwise_and.png](img/bitwise_shift_left.png)

<small>Источник изображения: [Pythonchik](https://pythonchik.ru/)</small>

**Пример**:

```python
a: int = 11
step: int = 1

c: int = a << step
print(c)  # 22
```

Сдвиг битов влево - сдвигает биты операнда на указанное количество битов влево, начиная с младшего бита. 
Пустые места после сдвига заполняются нулями.

### Сдвиг битов вправо

> Бинарный оператор

![bitwise_and.png](img/bitwise_shift_right.png)

<small>Источник изображения: [Pythonchik](https://pythonchik.ru/)</small>

**Пример**:

```python
a: int = 11
step: int = 1

c: int = a >> step
print(c)  # 5
```

Сдвиг битов вправо - сдвигает биты операнда на обозначенное количество битов вправо. 

- Если операнд положительный, то пустые места заполняются нулями. 
- Если же изначально работает с отрицательным числом, то все пустые места слева заполняются единицами.

Побитовые операторы использоваться для повышения эффективности кода, поскольку они часто работают быстрее, 
чем традиционные операторы.

---

## Логические операторы

Логические операторы позволяют сравнивать значения и принимать решения на основе результатов сравнения. 
Они часто применяются в условных конструкциях для управления выполнением кода.

### Таблица 4.4: Логические операторы

| Оператор |        Название         | Описание                                                                                           |
|:--------:|:-----------------------:|:---------------------------------------------------------------------------------------------------|
|  `and`   | логическое **И** (AND)  | возвращает `True`, если оба операнда являются истинными, и `False` в противном случае.             |
|  `or `   | логическое **ИЛИ** (OR) | возвращает `True`, если хотя бы один из операндов является истинным, и `False` в противном случае. |
|  `not `  | логическое **НЕ** (NOT) | возвращает `True`, если операнд является ложным, и `False`, если операнд является истинным.        |

### Логическое И (AND)

**Пример из жизни**:

- Вы планируете пикник и для этого нужно: чтобы **погода была солнечной** и **день был теплым**. 
  Только если оба условия выполнены, вы идете на пикник.

**Пример**:

```python
is_sunny: bool = True
is_warm: bool = True

result: bool = is_sunny and is_warm
print(result)  # True
```

### Логическое ИЛИ (OR)

**Пример из жизни**:

- Вы хотите выпить горячий напиток. Вы рады, если дома есть **кофе** или **чай** - вам не важно, что именно, 
  главное, чтобы хотя бы один из напитков был доступен.

**Пример**:

```python
has_coffee: bool = True
has_tea: bool = False

result: bool = has_coffee or has_tea
print(result)  # True
```

### Логическое НЕ (NOT)

**Пример из жизни**:

- Вы хотите пойти в парк, но только если **не идет дождь**.

**Пример**:

```python
is_raining: bool = True

result: bool = not is_raining
print(result)  # False
```

### Комбинирование логических операторов

Логические операторы можно комбинировать для создания сложных условий.

**Пример из жизни**:

- Вы выбираете куда пойти вечером если: 

  - Ваш друг свободен и у вас есть деньги, вы пойдете в кино.
  - Или, если на улице тепло, вы пойдете на прогулку.

**Пример**:

```python
friend_is_free: bool = True
i_have_money: bool = False
is_warm: bool = True

result: bool = (friend_is_free and i_have_money) or is_warm
print(result)  # True
```

### Приоритет логических операторов

Логические операторы имеют следующий порядок выполнения - приоритет:

- `not`
- `and`
- `or`

Это важно понимать, если вы работаете с выражениями, которые содержат несколько операторов.

**Пример из жизни**:

- 

**Пример**:

```python

```

Чтобы избежать неожиданное поведение программы, используйте скобки для явного указания порядка выполнения.

Для полного понимания логических операторов, вам необходимо знать таблицу истинности и базовых 
принципов [булевой алгебры](https://wiki.merionet.ru/articles/osnovy-bulevoj-algebry-true-false-xor-nor-i-logicheskie-simvoly).

### Таблица 4.5: Таблица истинности

|    A    |    B    | A `and` B | A `or` B | `not` A |
|:-------:|:-------:|:---------:|:--------:|:-------:|
| `True`  | `True`  |  `True`   |  `True`  | `False` |
| `True`  | `False` |  `False`  |  `True`  | `False` |
| `False` | `True`  |  `False`  |  `True`  | `True`  |
| `False` | `False` |  `False`  | `False`  | `True`  |

В Python существует только три логических оператора, хотя в программировании их количество больше.

---

### Операторы `in` и `not in`

Операторы `in` и `not in` предоставляют удобные способы проверки принадлежности элемента к последовательности
(строке, списку и др.).

Для примера, рассмотрим использование этих операторов со строками:

```python
sentence = "Python is a powerful programming language"

# Проверяем, содержит ли строка "Python" в себе
print("Python" in sentence)  # True

# Проверяем, содержит ли строка "Java" в себе
print("Java" in sentence)  # False

# Проверяем, что строка не содержит "programming"
print("programming" not in sentence)  # False

# Проверяем, что строка не содержит "JavaScript"
print("JavaScript" not in sentence)  # True
```

Также можем использовать эти операторы для проверки принадлежности элемента к списку:

```python
numbers = [1, 2, 3, 4, 5]

# Проверяем, содержится ли число 3 в списке
print(3 in numbers)  # True

# Проверяем, содержится ли число 6 в списке
print(6 in numbers)  # False

# Проверяем, что список не содержит число 0
print(0 not in numbers)  # True

# Проверяем, что список не содержит число 2
print(2 not in numbers)  # False
```

Это очень полезные инструменты, которые могут быть применены в ситуациях, где необходимо выполнить проверку
наличия или отсутствия элемента в контейнере данных.

---

### Операторы `is` и `is not`

Операторы `is` и `is not` предоставляют способ сравнения объектов на идентичность, то есть проверку, указывают ли они на
один и тот же объект в памяти. Эти операторы используются для сравнения объектов, а не их значений.

Простыми словами, эти операторы используются для сравнения идентификаторов объектов (вспомните функцию `id()`).

Рассмотрим примеры использования операторов `is` и `is not`:

```python
# Сравниваем два булевых значения
print(True is True)  # True
print(True is False)  # False

# Сравниваем две строки
print("Hello" is "Hello")  # True
print("Hello" is "World")  # False

# Сравниваем два числа
print(10 is 10)  # True
print(10 is 20)  # False

# Сравниваем переменные с одинаковыми значениями
x = [1, 2, 3]
y = [1, 2, 3]
print(x is y)  # False

# Сравниваем переменные, указывающие на один и тот же объект
a = [1, 2, 3]
b = a
print(a is b)  # True

# Сравниваем переменные с разными типами данных
print("Hello" is 10)  # False
print(True is 1)  # False
```

Важно понимать отличия между операторами равенства и `is` , что операторы равенства `==` и неравенства `!=` сравнивают
значения объектов, в то время как операторы `is` и `is not` сравнивают идентичность объектов в памяти. Выбор между этими
операторами зависит от контекста и требований конкретной задачи.

---

### `None` - специальное значение отсутствия значения

В Python существует специальное значение, называемое `None`, которое указывает на отсутствие
значения или на неопределенное состояние. `None` используется для обозначения переменных или объектов, которые не имеют
конкретного значения или ещё не были инициализированы.

Пример использования `None`:

```python
# Инициализация переменной без присвоения значения
some_variable = None

print(some_variable)  # None
```

Необходимо быть осторожным при работе с `None`, чтобы избежать ошибок, связанных с неправильным использованием или
некорректным сравнением значений. В данном контексте, без использования конструкций `if`, функций и других сложных
элементов, может быть сложно привести простые примеры, которые наглядно демонстрируют эти проблемы.

Однако, не волнуйтесь! Значение `None` будет более подробно рассмотрено в последующих темах, где мы сможем предоставить
более понятные и обстоятельные примеры использования и сравнения значения `None` с другими типами данных.

---

### Приоритет операторов

Операторы имеют различные уровни приоритета, что определяет порядок их выполнения в выражении. Понимание приоритета
операторов поможет вам правильно интерпретировать результаты выражений и избегать путаницы.

Рассмотрим несколько простых примеров:

**Арифметические операторы:**

```python
result = 2 + 3 * 4
print(result)  # Результат: 14
```

* В данном случае оператор умножения `*` имеет более высокий приоритет, чем оператор сложения `+`, поэтому он
  выполняется первым. Результат будет равен `2 + (3 * 4) = 2 + 12 = 14`.

**Операторы сравнения:**

```python
result = 5 < 3 == True
print(result)  # Результат: False
```

* Оператор сравнения `<` (меньше) имеет более высокий приоритет, чем оператор сравнения `==` (равно).
  Поэтому выражение сначала сравнивает `5 < 3`, что дает `False`, а затем сравнивает `False == True`, что дает `False`.

**Логические операторы:**

* Операторы `not`, `and` и `or` имеют следующий порядок приоритета (от наивысшего к наименьшему):

    - not
    - and
    - or

```python
result = not True or False and True
print(result)  # Результат: False
```

Сначала выполнится операция `not True`, которая даст результат `False`. Затем будет выполнена операция
`False or False and True`, где сначала выполнится `False and True`, результат `False`, а затем `False or False`,
конечный результат `False`.

Важно помнить, что при необходимости изменить порядок выполнения операций, всегда можно использовать скобки, чтобы явно
указать приоритет:

```python
result = (2 + 3) * 4
print(result)  # Результат: 20
```

В данном случае операторы в скобках выполняются первыми, а затем результат умножается на `4`. Результат будет
равен `(2 + 3) * 4 = 5 * 4 = 20`.

Это лишь некоторые примеры для демонстрации приоритета операторов. При работе с более сложными выражениями
всегда полезно обращаться к таблице приоритетов операторов для точного определения порядка их выполнения.

Таблица приоритетов операторов, операторы расположены по убыванию приоритета:

|                 Оператор                 | Описание                                           |
|:----------------------------------------:|:---------------------------------------------------|
|                   `()`                   | Группировка                                        |
|      ` x[index]`, `x[index:index]`       | Обращение к элементу или срезу в списке или строке |
|          `f(args...)`, `x.attr`          | Вызов функции или метода                           |
|                   `**`                   | Возведение в степень                               |
|             `+x`, `-x`, `~x`             | Унарные плюс, минус, инверсия                      |
|           `*`, `/`, `//`, `%`            | Умножение, деление, целочисленное деление, остаток |
|                 `+`, `-`                 | Сложение, вычитание                                |
|                `<<`, `>>`                | Побитовый сдвиг влево, вправо                      |
|                   `&`                    | Побитовое **И**                                    |
|                   `^`                    | Побитовое исключающее **ИЛИ**                      |
|           <code>&#124;</code>            | Побитовое **ИЛИ**                                  |
|     `<`, `<=`, `>`, `>=`, `==`, `!=`     | Сравнение                                          |
|                  `not`                   | Логическое **НЕ**                                  |
|                  `and`                   | Логическое **И**                                   |
|                   `or`                   | Логическое **ИЛИ**                                 |
|               `if` `else`                | Условный оператор `if` `else`                      |
|                 `lambda`                 | Лямбда-выражение                                   |
| `=`, `+=`, `-=`, `*=`, `/=`, `//=`, `%=` | Присваивание и составные операторы присваивания    |
|                   `:=`                   | Моржовый оператор                                  | 

---

### Моржовый оператор

_Этот раздел рекомендуется изучать после того, как ознакомитесь с темой `Условные операторы`. Условные операторы
представляют собой важную основу для понимания работы моржового оператора и его применения._

_Если вы уже знакомы с условными операторами и уверены в своих навыках работы с ними, можете приступить к изучению
раздела._

Моржовый оператор, также известный как оператор присваивания значения в выражении `:=`, является нововведением в Python
3.8. Он предоставляет удобный способ одновременного присвоения значения переменной и его проверки в условии. часто
используется для улучшения читаемости кода и уменьшения повторений. Вот несколько примеров, демонстрирующих применение
моржового оператора:

**Пример 1: Проверка и присвоение значения**

```python
# Пример с использованием моржового оператора
if (n := len(my_list)) > 0:
    print("Длина списка:", n)
else:
    print("Список пуст")

# Эквивалентный код без использования моржового оператора
n = len(my_list)
if n > 0:
    print("Длина списка:", n)
else:
    print("Список пуст")
```

**Пример 2: Присвоение значения**

```python
# Пример с использованием моржового оператора
if (value := 10) > 0:
    result = "Положительное число"
else:
    result = "Отрицательное число или ноль"
print(result)

# Эквивалентный код без использования моржового оператора
value = 10
if value > 0:
    result = "Положительное число"
else:
    result = "Отрицательное число или ноль"
print(result)
```

**Пример 3: Проверка и присвоение значения**

```python
# Пример с использованием моржового оператора
a = 5
b = 10
if (c := a + b) > 0:
    print("Сумма a и b:", c)
else:
    print("Сумма a и b меньше или равна нулю")

# Эквивалентный код без использования моржового оператора
a = 5
b = 10
c = a + b
if c > 0:
    print("Сумма a и b:", c)
else:
    print("Сумма a и b меньше или равна нулю")
```

Моржовый оператор позволяет компактно объединить присваивание и проверку в одной строке кода, делая код более читаемым и
эффективным.

**Важно:** Однако его следует использовать с умеренностью, чтобы не ухудшить читаемость кода.

---

Поздравляем! Вы изучили основные операторы, которые являются важным инструментом для работы с данными и
управления логикой программы.

В следующей теме `Основы коллекций в Python` мы углубимся в работу с различными типами коллекций данных, такими как
списки, кортежи, множества и словари.

---

### [Задания](./tasks/TASKS.md)


## Полезные ссылки:

- [Merion: Основы булевой алгебры: True, False, XOR, NOR и логические символы](https://wiki.merionet.ru/articles/osnovy-bulevoj-algebry-true-false-xor-nor-i-logicheskie-simvoly)
